# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    notes.txt                                          :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: tabadawi <tabadawi@student.42abudhabi.a    +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2024/04/09 14:36:05 by tabadawi          #+#    #+#              #
#    Updated: 2024/04/17 19:00:23 by tabadawi         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

*so to be clear from the start, im making my pipex in general whee it would handle more
 than one pipe (bonus), so i can use as is in minishell, and also understand better.

*salam introduced a very interesting concept of rather than allocaion for a million pipes as needed,
 only allocate for two, and each pipe has two sides, a read and a write side, where the pipe is sorta
 treated as a file, so u write into it from the left side, and the right side being read, as the output of
 the pipe will be used as the input for the next command

*we will be useing the same two pipes over and over, whenever a read is done, we close
 that pipe, so techmically we can open the same pipe again later on, and again, a pipe is
 techincally a file at this point, his explains what emran was saying earlier

*apparanty, as a "rule", read is always "0", and "write" is always "1", will check later
 (dup and dup2 function is important here ~ chris)

*the executables for the commands are stored all over the device, so we use execve to do them,
 but how do we get to them? we need to go to the path and fetch for them, so as far as im concerned,
 we will pass the "env" as a var to the main (huh?), split ot up to go thru the path, and cmp our command
 with whats stored in the path util we find it in the path and execuute it, else cmd not found

*we are always starting with an infile and ending with an outfile

*i need to look more into the functions that i have available to my use, those particularyly being
 (according to salam)"access", "dup2", "execve", "fork", "waitpid", (understand dup, you dont need to use it ~ chris)
 but ill look into all in general, and obv env vars

*with the mention of forks now that also means i have to understand what child and parent processes
 are and how they work together and how they get terminated

*so prior to any research, just according to that convo so far, here is how i believe it should flow:
 
 -open infile(first arg) and read from it
 -go thru the PATH looking for the second arg (cmd1)
 -pass what we read from the infile as input to cmd1
 -write the output of the command to a file (pipe)
 -read from the pipe file
 -go thru the PATH looking for the third arg (cmd2)
 -pass what we read from the pipe as input to cmd2
 -if 2 args is all we had, we close our second pipe placed after cmd2 and write to outfile
 -else use the second pipe file to repeat the process and keep swapping between pipe 1 and 2 as needed
 
*the env is passed as a double pointer (as essentially its an array of strings that contains
 the environment veriables passed) in the int main and then to navigate thru it we can loop thru it,
 in order for us to be able to actually use it, we are gonna loop thru the env till we find the path var and
 save it in a string, then split it up with : as that means diff directories, then loop thru that and check if
 access can return to us 0 as in the binary exists, and if so, run execve
 
*ok lots of experimenting today, i officially tried to execute a command and these are all the things ive learned
 -first of all we do have the path in the env, find it and store it in a 2d array
 -then we will have to make sure that we strjoin it with the path making sure there is a "/"
 -access will check for us if that executable is stored somewhere or not
 -if it is, we run execve which takes three things
		-the cmd path
		-a set of args, that being the command, its flags, and its params if any
		-the environment
 -now cool thing ab execve is basically once its executed it terminates the current process, whilst also
  doing a cleanup from within,m but it gets very confusing for when u have forks and diff processes
 -now in child process the memory is copied, and it has to be freed, or at least thats what i got, although
  chatgpt didnt exactly say that, thats what i concluded from testing, if execve is there, it cleans up on its own,
  else we have to manually do that
 -but for reference rn i need to find a way for when parsing to group the sections correctly for cmd and its flags
 -if im running one command i dont rlly need to fork but if i have multiple cmds and pipes, i need diff processes