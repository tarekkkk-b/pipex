# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    notes                                              :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: tabadawi <tabadawi@student.42abudhabi.a    +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2024/04/09 14:36:05 by tabadawi          #+#    #+#              #
#    Updated: 2024/04/09 15:41:13 by tabadawi         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

*so to be clear from the start, im making my pipex in general whee it would handle more
 than one pipe (bonus), so i can use as is in minishell, and also understand better.

*salam introduced a very interesting concept of rather than allocaion for a million pipes as needed,
 only allocate for two, and each pipe has two sides, a read and a write side, where the pipe is sorta
 treated as a file, so u write into it from the left side, and the right side being read, as the output of
 the pipe will be used as the input for the next command

*we will be useing the same two pipes over and over, whenever a read is done, we close
 that pipe, so techmically we can open the same pipe again later on, and again, a pipe is
 techincally a file at this point, his explains what emran was saying earlier

*apparanty, as a "rule", read is always "0", and "write" is always "1", will check later (Dup and Dup2 function is important here)

*the executables for the commands are stored all over the device, so we use execve to do them,
 but how do we get to them? we need to go to the path and fetch for them, so as far as im concerned,
 we will pass the "env" as a var to the main (huh?), split ot up to go thru the path, and cmp our command
 with whats stored in the path util we find it in the path and execuute it, else cmd not found

*we are always starting with an infile and ending with an outfile

*i need to look more into the functions that i have available to my use, those particularyly being
 (according to salam)"access", "dup2", "execve", "fork", "waitpid", (understand Dup, you dont need to use it)but ill look into all in general,
 and obv env vars

*with the mention of forks now that also means i have to understand what child and parent processes
 are and how they work together and how they get terminated

*so prior to any research, just according to that convo so far, here is how i believe it should flow:
 
 -open infile(first arg) and read from it
 -go thru the PATH looking for the second arg (cmd1)
 -pass what we read from the infile as input to cmd1
 -write the output of the command to a file (pipe)
 -read from the pipe file
 -go thru the PATH looking for the third arg (cmd2)
 -pass what we read from the pipe as input to cmd2
 -if 2 args is all we had, we close our second pipe placed after cmd2 and write to outfile
 -else use the second pipe file to repeat the process and keep swapping between pipe 1 and 2 as needed
 
*but now what am i parsing for? we will see post research